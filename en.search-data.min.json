[{"id":0,"href":"/getting-started/","title":"Getting Started","parent":"Suil C++ Framework","content":""},{"id":1,"href":"/getting-started/requirements/","title":"Requirements","parent":"Getting Started","content":"  Environment Dependencies  Required Libraries     Environment SCF currently targets Linux environments such as Ubuntu and Alpine. It has been tested on Alpine and Ubuntu x86_64 architecture. Support for other architectures hasn\u0026rsquo;t been tested, but supporting such architectures will require adding/verifying support for them on Suil/Libmill.\n Linux OS C++2a the build is continuously tested with gcc-10.2 but any other gcc compiler version that supports C++2a should work, otherwise the effort to make it work will be minimal Target compilation CPU should be x86_64. Other target\u0026rsquo;s haven\u0026rsquo;t been tested  Dependencies  Build Essential CMake CMake is used to generate targets of this project. I have only ever target Unix Makefiles generator, users are welcome to try other targets possible on Linux \u0026amp; GCC and provide feedback accordingly.  Required Libraries The following libraries presented in an typical apt package install command are required for development on Ubuntu or similar OS.\napt-get update apt-get install sqlite3 libsqlite3-dev libpq-dev postgresql \\  postgresql-server-dev-all uuid-dev openssl1.0 libssl1.0-dev \\  libzmq3-dev git bitcoin-core/secp256k1 is also required to build the crypto module. Follow installation instructions from the linked GitHub repo\nThis dependencies are just a hint on tested environments. Different environments might require different tool chains or libraries. Leaving that up to the developer to figure out. That being said, development on Linux has been simplified by providing docker images that can readily build this project. See Develop With Docker for more information on development options with docker  "},{"id":2,"href":"/documentation/scc/","title":"scc","parent":"Documentation","content":""},{"id":3,"href":"/documentation/cmake/Suil/","title":"Suil","parent":"CMake","content":"  SuilProject  Usage  Inputs Outputs   Example (How it works)   SuilTarget  Usage  Inputs Outputs       The scirpt Suil.cmake provide functions that abstract most of the CMake code need to setup a target that uses SCF. The script is installed with other CMake artifacts and need to be included in target project as follows\ninclude(Suil)SuilProject The API is used to initialize a target SCF project. When invoked the API might setup some environment variables on the parent scope depending on the provided parameters\nUsage SuilProject(name ...)Inputs Where name is the name of the project. The parameters that are available are documented below\n   Parameter Description     EXPORTS (ON|OFF) If set, the project will be configured to use modern CMake when installing libraries. See CMakePackageConfigHelpers documentation from CMake (default: OFF)   VERSION This is used to configure the version of the project (default: CMAKE_PROJECT_VERSION)   SCC_SOURCES A list of project level .scc source files that need to be transpiled by scc. Should the project be exported, generated header files generated from these sources will also be installed (optional)   PRIV_SCC_SOURCES These are project level private .scc sources that scc transpile into ${SCC_OUT_DIR}/private. Header files generated from these sources will not be installed.   SCC_OUTDIR A project level directory in which scc will transpile the given SCC_SOURCES into (default: ${CMAKE_BINARY_DIR}/scc)    Outputs    Variable Description     SUIL_PROJECT_VERSION The configure project level version (See input VERSION)   SUIL_SCC_PLUGINS_DIR Configured scc plugins directory. This is a list of directory which SCC will search for plugins. Set to ${CMAKE_BINARY_DIR} and ${SUIL_BASE_PATH}/lib   SUIL_PROJECT_SCC_OUTDIR This is the root project level directory that scc will use to generate it\u0026rsquo;s sources. It points to the input SCC_OUTDIR   SUIL_PROJECT_SCC_PUB The directory into which scc generates the given project level public sources (value ${SUIL_PROJECT_SCC_OUTDIR}/public)   SUIL_PROJECT_PRIV_PUB The directory into which scc generates the given project level private sources (value ${SUIL_PROJECT_SCC_OUTDIR}/private)   NAMESPACE This is the namespace that will be used for exported targets. It is set to named parameter name   TARGETS_EXPORT_NAME The name of the Targets export which is set to ${name}Targets    Example (How it works) SuilProject(hello-lib EXPORTS ON VERSION ${CMAKE_PROJECT_VERSION} SCC_SOURCES scc/pub/hello.scc PRIV_SCC_SOURCES scc/priv/debug.scc)SuilShared(hello SOURCES ${SUIL_PROJECT_SCC_PUB}/hello.cpp ${SUIL_PROJECT_SCC_PRIV}/debug.cpp INSTALL ON)This will initialize a project named hello-lib and configures it as a relocatable package when installed (EXPORTS ON).\nThe project also configures project level public SCC_SOURCES and private PRIV_SCC_SOURCES. These sources will be transpiled and it\u0026rsquo;s up to the user to add the generated sources to their targets by using the output variables SUIL_PROJECT_PRIV_(PRIV|PUB)\nSuilTarget This API is used to create a target and initialize it for dependency on provided SCF libraries. This function also abstract a lot of code that would be written to configure a target.\nUsage SuilTarget(name ...)Where name is the name of the project. The parameters that are available are documented below\nInputs    Parameter Description     TEST (ON|OFF) If set to ON, the target created will be an executable test binary (default OFF)   LIBRARY (SHARED|STATIC) If set, the target created will be a library with the given type. (default: not set)   SCC_OUTDIR If directory in which scc will transpile .scc sources to if SCC_SOURCES was provide. If this directory is not provide the project level directory with target name appended is used (i.e ${PROJECT_SCC_DIR}/name)   DEPENDS A list of other CMake targets defined for this current project that the target being defined needs.   VERSION The version of the target being defined. If this is not specified the version defined (or defaulted) invoking SuilProject will be used. This version is added as a define to the target as either LIB_VERSION or APP_VERSION   SOURCES The list of source files need that make up the target. If source files are not, this function will recursively look for C/C++ source files under directory src (i.e all files that end in .c,cc and .cpp extension. CMake recommends manually specifying target source files and this recommendation is also applicable here.   LIBRARIES A list of libraries that this target needs for compilation or linking against. The can be SCF libraries (e.g Suil::Base), CMake package libraries found using find_package(...) or system libraries (e.g math for -lmath).\nIf the package is a library, the are added to the library as PUBLIC libraries and will be required to link against the target.   PRIV_LIBS A list of libraries that will be added to the target library as PRIVATE. This are the libraries that the target needs to build but are not needed when linking against the target. This is only useful if the target is a library   INF_LIBS Interface libraries are only only added to the targets INTERFACE_LINK_LIBRARIES but are not used for linking the target. These are need only to link against the target. Also only useful for exported targets   PRIV_INCS A list of include directories needed to compile the current target but not needed by users of the target. This option only useful on exported targets. See CMake target_include_directories for more info   INCLUDES A list of PUBLIC directories that will be added to the target with target_include_directories. Note that if this is not configured, this API will try to default to the directory ${CMAKE_CURRENT_SOURCE_DIR}/$include/${name}   INF_INCS A list of include directories needed to compile a target that links against the current target but not needed to build the current target. CMake target_include_directories documents this better   DEFINES A list of defines that will be onto the target. These are always added as PUBLIC definitions and will be added to the INTERFACE_COMPILE_DEFINITIONS property of the exported target   PRIV_DEFS A list of private defines needed to compile the current target. Added to the target as PRIVATE   INF_DEFS A list of defines added to target as INTERFACE. As with other CMake API\u0026rsquo;s, these are not used to compile the current target but added to the INTERFACE_COMPILE_DEFINITIONS of the exported target   INSTALL (ON|OFF) Enable installing targets. If set to ON, CMake will configure installation for the target (and include directories if target is a library)    Outputs "},{"id":4,"href":"/documentation/cmake/","title":"CMake","parent":"Documentation","content":"    Suil     "},{"id":5,"href":"/getting-started/develop-with-docker/","title":"Developing With Docker","parent":"Getting Started","content":"  Development With Docker  Useful Docker Images Visual Studio Code Remote Development     Development With Docker The good news is that this project includes a prebuilt container with all dependencies pre-installed that can be used for development or continuous integration.\nUseful Docker Images The following docker images will help when developing SCF or with developing with SCF. Their Dockerfiles are currently hosted in a GitLab Group and have minimal CI. I plan to move them to GitHub at some point\n  suilteam/base This image can be used in CI environments to build SCF project. The image includes all the libraries and tools needed to build the project. Projects depending on SCF can have their docker images depend on this image. The image is hosted at Dockerfile Repo. The image has the following tags;\n suilteam/base:ubuntu for developing on Ubuntu suilteam/base:alpine for developing on Alpine    suilteam/remote:ubuntu This image extends the suilteam/base:ubuntu image by adding openssh server. The idea here is that this can actually be used for remote development and we can install anything we might need to make development easier. This is the image I currently use when developing on Mac OS with CLion IDE or VS Code Remote-Containers environment\n  Visual Studio Code Remote Development This project is setup up with Visual Studio Code Remote Development. If one has visual studio code and docker installed, they can launch the remote development environment in seconds and start developing and building. The environment will launch 3 containers\n Redis and PostgreSQL container A devel container which is the container we are actually developing on. The container features the following defaults;  built on top of suilteam/remote:ubuntu zsh and oh-my-zsh installed and set as default shell Memory limit of 16g Exposes ports 8000-8099    See Visual Studio Code Remote Development\n"},{"id":6,"href":"/documentation/","title":"Documentation","parent":"Suil C++ Framework","content":""},{"id":7,"href":"/getting-started/how-to-compile/","title":"How to Compile","parent":"Getting Started","content":"  SCF thrives to be a framework that can be used to create micro service components in C++. To that end the framework leans towards development with docker for docker. These instructions were tested docker but should be applicable even without docker as long as dependencies are installed.    Clone the the repo\ngit clone https://github.com/dccarter/suil.git This optional step opens up suil project in a docker container.\ndocker run -it --rm --name suil-dev -v `pwd`/suil:/home/suil -w /home/suil suilteam/remote:ubuntu bash     Create a build directory and run CMake from the this directory to generate the project build files\nmkdir build cd build cmake ..-DCMAKE_BUILD_TYPE=Debug The following options are available for configuring the build\n   Build option Explanation     CMAKE_BUILD_TYPE Can be used to specified the build type (or configuration). This provided by and CMake is well documented at their website   CMAKE_INSTALL_PREFIX This optiona can be used to specify the installation directory that will be used when installing the build.   ENABLE_UNIT_TESTS (ON|OFF) If set to ON, CMake will generate unit test targets (default: ON)   ENABLE_EXAMPLES (ON|OFF) If set to ON CMake will generate targets for examples included in project (default: ON)   SUIL_ENABLE_BACKTRACE (ON|OFF) Enable back tracing API. When enabled, message logged with Critical log level will include a backtrace (default: OFF)   SUIL_ENABLE_TRACE (ON|OFF) Enable trace logging in debug builds. Trace logging is very verbose and only available in debug builds (default: ON)      After successfully building a project, third party dependencies need to be built before attempting to build any other component.\nmake deps This step needs to be run when 3rdParty dependencies have been updated to pull the updates.\n  Build the project with the following command (if your machine has the power to parallelize make, please do so by appending -jN to the command where N is the desired parallelism)\nmake This command will build suil libraries, scc generator plugins , unit tests and examples (if enabled).\n  The project binaries can also be installed on the target system by using the make install command. This will install all suil libraries, their associated header files, generate CMake files and scc header files.\ncd suil mkdir -p build cd build cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=`pwd`/artifacts ... make deps ... make -j7 ... make install package  Note that I change the install prefix -DCMAKE_INSTALL_PREFIX=$(pwd)/artifacts to allow make to install artifacts to a directory named artifacts within my current directory. Install is combined with package above. suil supports generating compressed archives of install-ables which can be copied to another directory/system and installed without having to rebuild     "},{"id":8,"href":"/documentation/libs/","title":"Libraries","parent":"Documentation","content":""},{"id":9,"href":"/getting-started/app-dev-tutorial/","title":"Tutorial","parent":"Getting Started","content":"  Develop With SCF  Getting started with a template project  A Closer Look at CMakeLists.txt     Conclusion   It is really easy to develop applications against SCF. One either has to compile and generate artifacts from SCF and create an application that links against them.\nDevelop With SCF SCF provides CMake utility scripts to simplify developing applications or libraries that depend on SCF. All the developer needs is an SCF build and Suil Project Template.\nThis tutorial assumes you have SCF binaries downloaded to $(pwd)/scf/artifacts\nGetting started with a template project   Clone the template repo to a directory with your desired project name\ngit clone https://github.com/dccarter/suil-template hello-world cd hello-world rm -rf .git   Build the template hello-world project\n# Launch project in a docker container docker run -it --rm --name suil-dev \\  -v $(pwd)/scf/artifacts:/home/scf/artifacts \\  -v $(pwd)/hello-world:/home/scf/hello-world \\  -w /home/scf/hello-world \\  suilteam/remote:ubuntu bash # Build the project mkdir -p build cd build cmake .. -DCMAKE_BUILD_TYPE=Debug -DSUIL_BASE_PATH=/home/scf/artifacts make deps -j4 make # Execute the built hello world app ./hello-world # Outputs-\u0026gt; global: Hello World! This is suil world   The template contains the following files. Note that these files are for reference only\n   File/Directory Description     3rdParty.cmake This file contains 3rdParty projects not exported within SCF package but needed to build dependent applications   .gitattributes This file is not needed to build suil, but it will help github highlight .scc files as C++ files   .gitignore Not needed for the build but it is what I use as my .gitignore file   src This folder contains the source code of the app or library   test his folder contains unit testing source code.   CMakeLists.txt Contains the code that drives CMake. There is nothing special in this file      A Closer Look at CMakeLists.txt The following is the listing for the CMakeLists.txt template file. It uses Suil.cmake to configure an application\n2  project(hello-word LANGUAGES C CXX)   This is the line that declares the name of the project. Change this to whatever you wish to name your project (See CMake Project for more info)\n4 5 6 7  set(SUIL_BASE_PATH \u0026#34;\u0026#34; CACHE STRING \u0026#34;The root path when SCF is installed\u0026#34;)if (SUIL_BASE_PATH) set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${SUIL_BASE_PATH}/lib/cmake)endif()   Do not change this code block unless you know what you are doing. The code includes scf artifacts in the module lookup path for CMake. (See CMAKE_MODULE_PATH for more info)\n9  include(Suil)   This includes Suil.cmake from scf artifacts. This script provides CMake utility functions/macros used in this project.\n11 12 13  # Create a suil project SuilProject(hello-world SUIL_LIBS Base)   This will initialize the project declared in line #2. This function should only be invoked once with the name of the project. SuilProject is a function provided by suil and includes most of the CMake code that would be needed to setup an SCF project. See SuilProject for how to use the function\n15 16 17 18 19  # Create an application target SuilApp(hello-world SOURCES src/main.cpp LIBRARIES Suil::Base INSTALL ON)   This code block will create an executable target. The parameters to given SuilApp are self explanatory. See SuilApp for all the supported parameters.\nConclusion Using this template and Suil.cmake is not a requirement in developing SCF apps/libraries. Any developer familiar with CMake can rollout a project that depends on suil in a matter of minutes without using the helper script and the template.\nAlso note that there is nothing special about the CMakeLists.txt included in the template. If the target project needs what\u0026rsquo;s more that provided by Suil.cmake, any other requirements can still be added in the CMakeLists.txt.  !!! Happy Coding !!!!\n"},{"id":10,"href":"/categories/","title":"Categories","parent":"Suil C++ Framework","content":""},{"id":11,"href":"/","title":"Suil C++ Framework","parent":"","content":"Site is still work in progress\u0026hellip; This documentation site is still work in progress. Some links on this site might point to pages that haven\u0026rsquo;t been published yet. Use the side menu bar currently to navigate around   Introduction  Scope   What is SCF  Hello World   SCF Features  SCF HTTP/1 Web API Features Giving credits where they are due     Introduction Suil C++ Framework\nWeirdly named suil, a name I derived from a word (swele) in my native language which translates to the best. This is a project I started back in my student days as a way for me to keep sharpening my C++ programing skills. The project keeps growing and getting better as I learn new software concepts and the C++ standard changes. This is a work in progress project that is evolving with time and inspiration from other exciting open source projects.\nScope The purpose of this document is to introduce and document SCF. While going through the documentation, please heed to all warnings/advices given as the project tend to use bad programing paradigms that still haunt me from my novice days and needs special attention when using them.\nWhat is SCF SCF is a software development framework providing various C++ libraries that can be used to build or quickly prototype Linux applications. The framework targets the web applications space by providing re-usable software components that can be assembled into usable web applications without (or with less) effort. Coming from an embedded background, I always thrive for performance and low memory usage and some of the concepts employed in this project were an attempt to either make things faster or to reduce memory usage. Where possible the project avoids depending on complex libraries and provides simpler implementations.\nHello World #include \u0026#34;suil/http/server/endpoint.hpp\u0026#34; namespace hs = suil::http::server; namespace net = suil::net; int main(int argc, char *argv[]) { using Server = hs::Endpoint\u0026lt;\u0026gt;; // Create an http endpoint that uses default configurations  Server ep(\u0026#34;/\u0026#34;); // GET http://localhost/hello  Route(ep, \u0026#34;/hello\u0026#34;) (\u0026#34;GET\u0026#34;_method, \u0026#34;OPTIONS\u0026#34;_method) (Desc{\u0026#34;Route returns hello world\u0026#34;}) .attrs(opt(ReplyType, \u0026#34;text/plain\u0026#34;)) ([\u0026amp;]() { // body will be cleared after response  return \u0026#34;Hello World!\u0026#34;; }); // GET http://localhost/echo  Route(ep, \u0026#34;/echo\u0026#34;) (\u0026#34;GET\u0026#34;_method, \u0026#34;OPTIONS\u0026#34;_method) (Desc{\u0026#34;Route returns whatever was given in the request body\u0026#34;}) .attrs(opt(ReplyType, \u0026#34;text/plain\u0026#34;)) ([\u0026amp;](const hs::Request\u0026amp; req, hs::Response\u0026amp; res) { // Chunked response buffer to support zero copy  res.chunk({const_cast\u0026lt;char *\u0026gt;(req.body().data()), req.body().size(), 0}); }); return ep.start(); } SCF Features Everything in suil is developed with coroutines in mind (thanks to Libmill). Imagine go but in C++\n   Features What\u0026rsquo;s up     Suil Code Compiler scc is a plugin base tool that can transform a defined subset of C++ header file content to a syntax tree that can be crunched by plugins (generators) to generate code.   Logging Customizable printf style logging   Mustache SCF includes a cached mustache template parser and renderer   JSON Includes a static JSON decoder/encoder from IOD and dynamic parser/encoder   Cryptography wrappers Wrappers around OpenSSL API\u0026rsquo;s - mostly the the kind you will find in blockchain implementations   Binary Serialization protocol A custom binary serialization protocol (currently work in progress and open for major improvements) which is dubbed suil   PostgreSQL database A very easy to use PostgreSQL client. This client is based on coroutines and provides a nice API. Supports cached connections and statements   Redis Database Client A hand written Redis client based on the spec. Provides cached connections and implements most features of Redis. It is easy to add features to this client to keep up with redis   Sockets Library Libmill provide some API\u0026rsquo;s that abstract Unix socket API\u0026rsquo;s. SCF Sockets Library provide easy to use C++ abstractions of top of libmill abstractions   ZMQ Abstraction A very beautiful and easy to use ZMQ API abstraction on to of the C ZMQ library   SMTP Client and Server A fully fledged SMTP client which can be used to send emails to SMTP servers. The server implementation is minimal and can be used to prototype an SMTP servers for testing environments. An SmtpOutbox is provided to avoid having to wait for mail server to respond when sending SMTP emails   RPC Framework SCF provides A gRPC like easy to use framework but very light weight based on Suil Code Compiler and corresponding rpc generator written for scc.   JSON RPC Clean and easy to use JSON RPC framework and is compliant with JSON RPC 2.0 spec.   Suil RPC An RPC which custom suil binary serialization protocol (binary) for encoding data that goes on the wire   scc RPC generator An scc generator which generates RPC services from .scc code files. i.e this generator transforms a C++ class definition (with some syntactic sugar) into either SRPC/JRPC client API and server API'   HTTP/1 Web API The backbone of this project started it all. This API tries to simplify developing HTTP web applications and features with C++; See the HTTP features below   HTTP/1 Client A clean session based HTTP/1 client   WebSocket Server Provides API\u0026rsquo;s that can be used to develop robust websocket servers   HyperLedger Sawtooth SDK A fully fledged and easy to use HyperLedger sawtooth client   Mongo DB CLient Coming soon\u0026hellip; building from spec\u0026hellip;    SCF HTTP/1 Web API Features  An easy to use parameter based static and dynamic routing API Middleware based endpoints Application Initialization Middleware which can be used to provide an initialization route for the API while blocking all the other routes System Attributes Middleware can be added to the endpoint to allow adding features that toggle options on the endpoint (e.g enabling/disabling authentication on specific route) One-line method call for Route Administration and API documentation, this expose\u0026rsquo;s routes that can be used to administer the endpoint, including enabling/disabling routes and querying route metadata (Admin Only) JSON Web Token API\u0026rsquo;s which can be used to create JWT tokens and verify them JWT Authorization Middleware is available for JWT authentication. When added to an endpoint, it will validate all routes marked with Authorize attribute and reject all unauthorized requests JWT Session Middleware builds on top of JWT Authorization and Redis Middlewares by implementing session based JWT (i.e the refresh/accept token ideology) Redis and PostgreSQL middlewares which when attached to an endpoint, can be used as database connection providers for the endpoint File Server which can be used to serve the contents of any directory. This is still missing some features but thrives to be very fast and reliable.  Supports cached files, i.e files are cached in an L.R.U cache Range based requests Cache headers Easy configuration API. e.g fs.mime(\u0026quot;js\u0026quot;, opt(allowCache, true)) will allow the server to cache javascript files There is still some of work to here but current implementation serves basic needs    Giving credits where they are due The following list of open source libraries are used in SCF is third party dependencies\n   Library How it is used     Libmill Libmill is the core of this project. It provides the the coroutine concurrency used across the the project. SCF uses a modified version of this library Suil/Libmill. The main modification introduced in the aforementioned repo is multi threading and API\u0026rsquo;s that are commonly used in multi thread applications   IOD IOD is a library that enhances C++ meta programing. suil uses this library intensively more specifically around it\u0026rsquo;s json encoding/decoding features and it\u0026rsquo;s symbol types. An extensible code generator (scc or Suil Code Compiler), was created to support generating IOD symbols and suil meta types.   Crow Crow provides the routing and middleware dispatch magic that is used in the HTTP server code. See suil/http/server/crow.hpp, suil/http/server/rch.hpp which includes code copied from crow and modified accordingly   Catch Catch is used across the project for writing unit tests    Any other code that might have been used, either modified or copied as is, the original licence text kept at the top of the file or comment with a link to the source of the snippet is included\n"},{"id":12,"href":"/tags/","title":"Tags","parent":"Suil C++ Framework","content":""}]